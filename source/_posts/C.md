---
title: C
date: 2023-07-27
tags: ['星海']
categories: 星海
id: C
---

# C 

# 目录
- [快速判断是否是字母](#section.1)<a name="context.1"> </a>
- [快速判断两字符是否相同且为字母](#section.2)<a name="context.2"> </a>
- [C 关键字](#section.3)<a name="context.3"> </a>
  - [free/malloc](#section.4)<a name="context.4"> </a>
  - [float/double](#section.5)<a name="context.5"> </a>
  - [union/volatile](#section.6)<a name="context.6"> </a>
------------------------------------------------

<!-- more -->

**c语言宏 `__stdcall`, `__cdecl`**

​		调用函数时，计算机常用栈来存放函数执行需要的参数，由于栈的空间大小是有限的，在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示overflow。

​		在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的！

​		VC中默认调用是 `__cdecl` 方式，Windows API 使用 `__stdcall` 调用方式，在 DLL 导出函数中，为了跟 Windows API 保持一致，建议使用 `__stdcall` 方式。

C/C++ 函数调用约定，主要是对以下两个方面进行了约定：

1. 当参数个数多于一个时，按照什么顺序把参数压入堆栈。----调用函数时，参数的入栈顺序。
2. 函数调用后，由谁来把堆栈恢复原状。----调用结束后，由谁（调用者还是被调用者）负责将参数出栈。



在高级语言中，就是通过函数的调用方式来说明这两个问题的。常见的调用方式有：

```
C 语言:   __cdecl、__stdcall、__fastcall、naked、__pascal。
C++ 语言: __cdecl、__stdcall、__fastcall、naked、__pascal、__thiscall，比 C 语言多出一种 __thiscall 调用方式。
```



1. stdcall
   `__stdcall` 是 StandardCall 的缩写，是C++的标准调用方式。stdcall 调用方式又被称为 Pascal 调用方式。在Microsoft C++系列的C/C++编译器中，使用 PASCAL 宏，WINAPI 宏和 CALLBACK 宏来指定函数的调用方式为 stdcall。
   其声明语法为：

   ```
   int _stdcall function(int a, int b);
   ```

   stdcall的调用方式意味着：

   （1）参数从右向左依次压入堆栈.
   （2）由被调用函数自己来恢复堆栈，称为自动清栈。
   （3）函数名自动加前导下划线，后面紧跟着一个@，其后紧跟着参数的大小。

   

2. cdecl

   `__cdecl` 是C Declaration的缩写（declaration，声明），cdecl调用方式又称为C调用方式，是C语言缺省的调用方式。
   其声明语法为：

   ```
   int function(int a, int b);        // 不加修饰符就是C调用方式
   int _cdecl function(int a, int b); // 明确指定用C调用方式
   ```

   cdecl的调用方式意味着：

   （1）参数从右向左依次压入堆栈.
   （2）由调用者恢复堆栈，称为手动清栈。
   （3）函数名自动加前导下划线。

   由于是由调用者来恢复堆栈，因此C调用方式允许函数的参数个数是不固定的，这是C语言的一大特色。比如 `printf`



## [快速判断是否是字母](#context.1)<a name="section.1"> </a>

```c
# 包括大小写字母
(uchar)((ch | 0x20) - 'a') < 26
```



## [快速判断两字符是否相同且为字母](#context.2)<a name="section.2"> </a>

```c
((ch = ch1 ^ ch2) == 0) || (ch == 0x20) && ((unsigned)(ch1 | 0x20) - 'a') < 26
```



bit -> Byte -> kb	1Byte = 8bit

bit比特位	byte字节	且内存中一个空间占一个字节=8位

**负数在内存中存储的是补码，求原码-1然后除符号位其余取反**

**且任何数字在内存中都是以补码存储的，正数原反补都一样**

 

## [C 关键字](#context.3)<a name="section.3"> </a>

| **auto**     | **break**  | **case**   | **char**   | **const**  | **continue** | **default** | **do**    | **double**   | **else**   |
| ------------ | ---------- | ---------- | ---------- | ---------- | ------------ | ----------- | --------- | ------------ | ---------- |
| **enum**     | **extern** | **float**  | **for**    | **goto**   | **if**       | **int**     | **long**  | **register** | **return** |
| **short**    | **signed** | **sizeof** | **static** | **struct** | **switch**   | **typedef** | **union** | **unsigned** | **void**   |
| **volatile** | **while**  |            |            |            |              |             |           |              |            |

**typedef** unsigned int uint		把unsigned int重定义为unit

**void**							声明函数无返回值或无参数

**auto**							在局部中自动销毁原变量值

**static** 						静态局部变量，不会销毁，保存赋值

**const** **x**						定义常量x，不可改变

**extern**						声明外部-变量/函数

**#define** a 100					定义常量和宏，可以是三目运算符

 

| Char   | Short      | Int        | long   | long long | folat   | double        |
| ------ | ---------- | ---------- | ------ | --------- | ------- | ------------- |
| 字符串 | 短整型     | 整型       | 长整型 | 超长整型  | 浮点型  | 双精度浮点型  |
| 1字节  | 2字节/16位 | 4字节/32位 | 4字节  |           | 4/8字节 | 64位保留后6位 |

a<<2			a左移2位

| &                | \|                  | ^    | !    | ~        |
| ---------------- | ------------------- | ---- | ---- | -------- |
| 按位与           | 按位或              | 异或 | 非   | 按位取反 |
| a&&b（逻辑与）   | \|\|                |      |      |          |
| a, b均为真返回真 | 逻辑或,有一个返回真 |      |      |          |

 

%c			打印一个字符串格式的数据

%s			打印字符串

%d			整型十进制数据

%u			无符号的十进制整数

%f			浮点型

%g			浮点，不显示无意义的0

%lf			双精度浮点型

%p			指针，以地址的形式打印

%x			打印十六进制

%o			输出八进制数

%%			‘%’

 

float

(-1)^s * M * 2^E		s=0/1	E=n(8位,得加127)		M=1.?? (23位1.省略)	

​					S	E(8/11bit)	M(23/52bit)

double				同上，E(加减1023)

 

 

整型转换(小转整int)

算数转换(小转大)

​	long double

double

​	float

​	unsigned long int

​	long int

​	unsigned int

​	int

\>>			右移（除2），补符号位			左移补0,其他同

exp ? a : b	exp为真则返回a，否则返回b

 

do{循环语句}

while(判断);

 

b = a++		后置++表示先把a给b，a自己在++

​			前置相反

 

**函数****:**

​	声明放到.h中，int Add(int x, int y);	定义放到.c中

​	.h中 à		#ifndef __ADD_H__		//if not def 判断是否引用过ADD_H

​				#define __ADD_H__		//未引用为真，则往下运行

​				//函数声明

​				int Add(int x, int y);

\#endif					//到endif结束

scanf(“%d”, &n)		获得输入给n

printf(“%d”, n)			打印n

sizeof(char)			看char的长度，单位：byte字节

​					sizeof(数组名) / &数组名à表整个数组，其余均表地址

qsort()

strcat(1,2)			把字符串2加到1后面

assert(?)				**断言**，如果?为假则报错，否则继续运行

strcmp(1,2)			逐个比较字符串大小(ASCII)，1>2返回正数，1=2返回0，同

strncmp()				同上，比较前n位

strtok(arr,p)			arr,p为指针，在arr中按p切割

 

定义常量

const int n = 4			定义常变量，不能改变

\#define n 10			define定义的标识符常量

enum n				枚举常量

{a, b, c}			abc分别对应012

 

转义符：

\0		在字符串里表到这结束

​	\ddd		ddd表示1-3个八进制的数字，如：\130 表X

​	\xdd		dd表2个十六进制数字，\x30 表0

 

 

 

| C                |                             |          |      | Python         |                  |      |
| ---------------- | --------------------------- | -------- | ---- | -------------- | ---------------- | ---- |
| 输入             | scanf(“%d”, &a)             |          |      | 输入           | input()          |      |
| getchar()        | 获得输入                    |          |      |                |                  |      |
| 数组数组名为地址 | char arr[] = {‘x1’, ‘’…, 0} | 0必加    |      | 列表           | []               |      |
| char arr\[ ][n]  | 列不可省略                  |          |      |                |                  |      |
| 字符串长度       | strlen()                    |          |      | 字符串长度     | len(x)           |      |
| if ()            |                             |          |      | if …:          |                  |      |
| 需要定义变量     |                             |          |      | 不需要定义变量 |                  |      |
| 函数             | int Function(x ,y) {}       |          |      |                | def function: {} |      |
| 结构体           | struct Name{}               |          |      | 类             | Class            |      |
| 字符串           | 不能直接给变量得用数组      | strcpy() |      | 字符串         | 能直接给变量     |      |
| 转换类型         | (int)3.14                   | 3.14->3  |      | 转换类型       | int(3.14)        |      |

 

switch(x)

{

​	case 1: …; break;			加break表执行完退出switch，

​	case 2: …;					无break表执行完后继续往下执行

​	case n: …;

​	default: …; break;			表默认情况执行default的语句

}

 

 

 

**指针**		

数组默认传的是指针，如int arr[]; Function(arr)ßarr为指针，是arr[0]的地址

&a=0		取a的地址

int* b = &a	b为**指针**变量，存a的地址**,** 32位平台是4个字节，64位平台是8个字节

int**c=&*b	int**表c指向int*

*b = 20		*为**解引用操作符**，把20存放进b的地址中

 

arr				首元素地址

&arr[0]			首元素的地址

&arr				数组的地址

int (*p)[10]=&a	数组指针			à去掉名字就是类型

int (*p)(int int)=Add	函数指针

 

**结构体**

(typedef)struct Book		//加typedef则下面a为类型，如a s,定义了s结构体

{

​	char name[20];

​	short price;

}à(a)s1,s2;		//s1,s2为同Book的全局变量(python的class)

 

 

struct Book n1 = {“xxx”, 55};

struct Book* pc = &n1			//定义指针为pc，存结构体n1

printf(“%s”, pc->name)			//打印name，->表指向，即取该地址的name

 

srtcpy(n1.name, “new”)			//想改name用字符串拷贝，把new给name

 

**结构体内存对齐**

​		对齐到本身对齐数整数倍的地址处（参考上一个）

总大小为最大对齐数的整数倍

（嵌套结构体，按最大的字节算）

 

\# 数组随下表增长，地址从低到高变化

\# 栈区地址从高到低存

栈区à		局部变量

​			函数的形式参数

​			函数调用也开辟空间

堆区à		动态内存分配

​			Malloc/free

​			Realloc

​			calloc

静态区à		全局变量

​			静态变量	static

 

**枚举**

**enum Color**

**{**

​	**RED,**		//序号为0，也可以赋值

​	**…**

**}**

 

**数据内存存储模式（**以字节为单位**）**

1.小端		数据低位存内存低位		内存地址：低à高（左低右高）

2.大端		数据低位存内存高位		数据：高à低（左高右低）如二进制数

 

***划重点！！\*****à**	**Keil，C51为大端**		**X86为小端****，很多****ARM,DSP也为小端，有些ARM可选**

 

 

 

**C语言** à 编译    +    连接

​	编译生成目标文件		目标文件经过链接器，链接库处理，生成可执行文件

汇编 à 二进制

 

 

**预处理符号**

```
__FILE__				返回文件名+路径

__LINE__				返回所在行数

__DATE__			返回当今日期

__TIME__			返回当前时间
```

 

 

**文件处理**

FILE* pf = fopen(“log.txt”, “w”)			以只读打开/创建文件

fprintf(pf, “file:%s	line:%d	date:%s	time:%s	i=%d\n”,

__FILE__, __LINE__, __DATE__, __TIME__, i)			以格式化写文件

fclose(pf)				关闭文件

pf = NULL				指针清空

 

**运算效率**

移位 > 赋值 > 大小比较 > 加法 > 减法 > 乘法 > 取模 > 除法

 

 

**回调函数详述**

[C 语言回调函数详解 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/c-callback-function.html)



### [free/malloc](#context.4)<a name="section.4"> </a>

malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节

这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小

这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了





### [float/double](#context.5)<a name="section.5"> </a>

![img](https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/float.png)

- *符号位*：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；
- *指数位*：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，**指数位的长度越长则数值的表达范围就越大**；
- *尾数位*：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且**尾数的长度决定了这个数的精度**，因此如果要表示精度更高的小数，则就要提高尾数位的长度；



例：

![img](https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161639261.png)

**把小数点，移动到第一个有效数字后面**，即将 1010.101 右移 `3` 位成 `1.010101`，右移 3 位就代表 +3，左移 3 位就是 -3。

**float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了**，即指数位这 8 位存的是 `10000010`（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。

`1.010101` 这个数的**小数点右侧的数字就是 float 里的「尾数位」**，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 `01010100000000000000000`。

这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，**既然这一位永远都是 1，那就可以不用存起来了**。

于是就让 23 位尾数只存储小数部分，然后在计算时会**自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点**。

那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：

![img](https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640274.png)

![img](https://cdn.jsdelivr.net/gh/WYinhui/MyPicGo@master/img/202308161640766.png)



**TIPS:**

> **为什么负数要用补码表示？**

负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。

> **十进制小数怎么转成二进制？**

十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。

> **计算机是怎么存小数的？**

计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：

- 符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；
- 指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；
- 尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；

用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。

> **0.1 + 0.2 == 0.3 吗？**

不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。

因此，IEEE 754 标准定义的浮点数只能根据精度舍入，然后用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。

0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，只能根据精度舍入，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。



### [union/volatile](#context.6)<a name="section.6"> </a>

**union**

共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。其占内存为最大成员

```c
union data{
    int n;
    char ch;
    double f;
};
union data a, b, c;
// sizeof(data) 为 sizeof(double) = 8
```



**volatile**

修饰异变的参数，每次都要去寄存器或内存重新读取

只要变量可能被意外的修改，就需要把该变量声明为volatile。在实际应用中，只有三种类型数据可能被修改：

- 外设寄存器地址映射
- 在中断服务程序中修改全局变量
- 在多线程、多任务应用中，全局变量被多个任务读写



