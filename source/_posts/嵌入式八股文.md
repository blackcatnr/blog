---
title: 嵌入式八股文
date: 2023-08-29
tags: ['星海']
categories: 星海
id: 嵌入式八股文
---
<!-- more -->
# 嵌入式八股文
# 目录
- [芯片选型考虑哪些因素？](#section.1)<a name="context.1"> </a>
- [STM32F4和F1的区别，为什么选用F4？](#section.2)<a name="context.2"> </a>
- [STM32启动过程：](#section.3)<a name="context.3"> </a>
- [stm32的定时器](#section.4)<a name="context.4"> </a>
- [stm32的AD采样](#section.5)<a name="context.5"> </a>
- [Linux嵌入式和单片机嵌入式区别：](#section.6)<a name="context.6"> </a>
- [FreeRTOS、μC/OS的区别](#section.7)<a name="context.7"> </a>
- [在RTOS中，二值信号量和互斥量的区别？](#section.8)<a name="context.8"> </a>
- [在RTOS中，任务通知的运行机制是怎么样的？](#section.9)<a name="context.9"> </a>
- [UCOS任务调度](#section.10)<a name="context.10"> </a>
- [UCOS中任务间的通信](#section.11)<a name="context.11"> </a>
- [STM32 中断是怎么进入到中断服务程序的](#section.12)<a name="context.12"> </a>
- [UCOS中断处理过程](#section.13)<a name="context.13"> </a>
- [DMA有什么用](#section.14)<a name="context.14"> </a>
- [处理器与外部设备通信的两种方式](#section.15)<a name="context.15"> </a>
- [串行通信的通信方式](#section.16)<a name="context.16"> </a>
- [串行通信分为](#section.17)<a name="context.17"> </a>
- [Modbus通讯协议](#section.18)<a name="context.18"> </a>
- [485通讯的原理](#section.19)<a name="context.19"> </a>
- [RS485和RS232的区别](#section.20)<a name="context.20"> </a>
- [串口通信协议UART](#section.21)<a name="context.21"> </a>
- [串口异步通信](#section.22)<a name="context.22"> </a>
- [SPI（串行外围设备接口）](#section.23)<a name="context.23"> </a>
- [SPI是什么？有几条线？几种模式？](#section.24)<a name="context.24"> </a>
- [IIC](#section.25)<a name="context.25"> </a>
- [CAN通信介绍](#section.26)<a name="context.26"> </a>
- [传输速度](#section.27)<a name="context.27"> </a>
------------------------------------------------  

## [芯片选型考虑哪些因素？](#context.1)<a name="section.1"> </a>

1. 性能：确保芯片具有足够的处理能力来满足项目需求。
2. 内存：选择具有足够RAM和ROM（或Flash）容量的芯片。
3. 能耗：根据项目要求，权衡功耗和性能。
4. 外设和接口：选择支持所需通信协议和设备连接的芯片。
5. 封装和尺寸：考虑空间限制和生产要求，选择合适的封装类型。
6. 开发工具和支持：选用具有良好文档和支持的芯片，降低开发难度。
7. 供应和成本：确保稳定供应并选择性价比合适的芯片。
8. 软件和生态系统：选择具有成熟软件支持和丰富生态系统的芯片。
9. 安全性：根据项目要求，选择具有相应安全功能的芯片。
10. 可扩展性：选择具有一定可扩展性和升级能力的芯片，以适应项目需求变化。

## [STM32F4和F1的区别，为什么选用F4？](#context.2)<a name="section.2"> </a>

内核不同：F1是Cortex-M3内核，F4是Cortex-M4内核；

主频不同：F1主频72MHz，F4主频168MHz；

浮点运算：F1无浮点运算单位没有硬件FPU处理浮点数运算，F4有；

（没有浮点加速硬件FPU只影响浮点计算的速度，并不是不能计算浮点数，因此只能通过内核的软件进行计算。先要把这个浮点数运算转换成定点数存储，再把这个定点数转换成指数的方式进行运算，不仅中间要进行数据转换，并且要进行多次移位，而整数型就不需要这么复杂的操作，直接运算就可以，所以F1浮点数运算不仅运算量大并且会加大MCU的负载，要慢很多）

功能性能：F4外设比F1丰富且功能更强大，比如GPIO翻转速率、上下拉电阻配置、ADC精度等；

内存大小：F1内部SRAM最大64K，F4有192K(112+64+16)。

F4的RAM和ROM：ram192K，rom大小2048K

考虑到需要浮点运算和使用RTOS系统，最后选择F4；

## [STM32启动过程：](#context.3)<a name="section.3"> </a>

1. 复位向量表（Reset Vector Table）：在STM32微控制器中，复位向量表是一个存储器区域，其中包含了处理器在复位时跳转执行的第一条指令的地址。通常，复位向量表位于存储器的起始地址，由芯片制造商预先定义。复位向量表的内容包括复位中断处理函数、中断向量表和其他初始化函数。
2. 处理器复位：当STM32芯片上电或者外部复位信号触发时，处理器的复位引脚将会被拉低，导致处理器执行复位操作。在复位期间，处理器会将各个寄存器的值初始化为默认值，并开始执行复位向量表中的第一条指令。
3. 系统初始化：复位向量表中的第一条指令通常是一条跳转指令，将控制权转移到系统初始化函数的地址上。系统初始化函数主要用于设置处理器和系统的一些基本配置，例如时钟源和时钟频率的配置，初始化堆栈指针、全局变量等。
4. C库初始化：在系统初始化完成后，通常会调用C库的初始化函数。C库的初始化函数主要是对C语言运行环境的初始化，包括清零BSS段（未初始化的全局变量）、复制数据段（初始化的全局变量）等。
5. 主函数入口：C库初始化完成后，处理器将跳转到主函数的入口地址开始执行用户程序。主函数是程序的入口点，其中包含应用程序的具体逻辑。

需要注意的是，上述步骤是一般情况下的启动流程，具体的启动过程可能会因不同的芯片型号、启动模式和编译器设置而有所差异。此外，还可以通过修改复位向量表的内容来实现特定的启动操作，例如自定义复位中断处理函数或添加其他初始化函数。

## [stm32的定时器](#context.4)<a name="section.4"> </a>

提问定时器相关的，具体根据你个人开发使用情况解答。

1. 定时器时钟使能：首先，需要使能所需的定时器时钟。这可以通过RCC（Reset and Clock Control）寄存器来配置。例如，如果要使用TIM2定时器，需要使能TIM2的时钟。
2. 定时器配置：配置定时器的基本参数，例如计数器的工作模式、时钟分频系数、计数器的自动重载值等。这些配置可以通过定时器的相关寄存器进行设置。
3. 定时器中断设置（可选）：如果需要使用定时器中断，可以配置中断源和中断优先级，并使能定时器中断。
4. 启动定时器：配置完成后，启动定时器开始计数。定时器可以通过软件触发或外部触发来启动计数。
5. 定时器中断处理（可选）：如果配置了定时器中断，当计数器达到设定的值时，会触发中断。在中断服务程序中可以执行相应的操作，例如更新计数器的值、处理中断标志等。

## [stm32的AD采样](#context.5)<a name="section.5"> </a>

提问AD采样相关的，具体根据你个人开发使用情况解答。

1. ADC配置：首先，需要配置ADC模块的相关寄存器，包括时钟使能、采样时间、采样通道等。这些配置可以通过寄存器操作或者使用STM32提供的库函数进行设置。
2. GPIO配置：为了使用ADC，需要将相应的GPIO引脚配置为模拟输入模式，并使能相应的ADC通道。这可以通过配置GPIO寄存器来完成。
3. 触发方式设置：可以选择触发ADC转换的方式，例如软件触发或外部触发。如果选择外部触发，还需要配置相关的触发源和极性。
4. ADC转换：在进行ADC转换之前，可以设置ADC分辨率、对齐方式、连续转换模式等。然后，可以通过启动转换命令或触发源来开始ADC转换。
5. 中断或轮询获取结果：可以选择使用中断或轮询的方式获取ADC转换结果。如果使用中断方式，可以在转换完成后触发中断，并在中断服务程序中读取转换结果。如果使用轮询方式，则需要在转换完成后主动查询并读取转换结果。
6. 结果处理：获取到ADC转换结果后，可以根据需要进行相应的处理，例如数据转换、单位换算等。

## [Linux嵌入式和单片机嵌入式区别：](#context.6)<a name="section.6"> </a>

复杂性：Linux嵌入式系统是基于Linux内核构建的，具有完整的操作系统功能，包括多任务处理、文件系统、网络协议等。相比之下，单片机嵌入式系统通常使用裸机编程或者实时操作系统（RTOS），具有更简单的系统结构和功能。

处理能力：Linux嵌入式系统通常在较强大的处理器上运行，例如ARM、x86等，具备较高的处理能力和存储容量。而单片机嵌入式系统使用单片机芯片，其处理能力和存储容量较低。

开发环境：Linux嵌入式系统使用标准的开发工具链和开发环境，可以使用高级编程语言（如C/C++）进行开发，并且具备广泛的软件支持和开发社区。单片机嵌入式系统的开发通常需要使用特定的单片机编程工具和汇编语言，开发资源相对较少。

系统定制性：Linux嵌入式系统具有很高的可定制性，可以根据应用需求选择所需的软件组件和功能，并且支持模块化的软件开发和更新。单片机嵌入式系统的定制性相对较低，往往需要在设计阶段确定所需功能和硬件配置。

成本和功耗：Linux嵌入式系统由于使用较高性能的处理器和较大容量的存储器，相对而言成本较高，并且功耗较高。单片机嵌入式系统由于采用低成本、低功耗的单片机芯片，成本较低且功耗较低。

总的来说，Linux嵌入式系统适用于需要复杂功能、较高性能和较大存储容量的应用，如智能手机、平板电脑、网络设备等。而单片机嵌入式系统适用于资源有限、功耗要求低、对实时性要求较高的应用，如传感器、家电、汽车电子等。

## [FreeRTOS、μC/OS的区别](#context.7)<a name="section.7"> </a>

开源性质：FreeRTOS是一个开源的RTOS，可以免费获取并在商业和非商业项目中使用。它具有广泛的用户社区和支持。而μC/OS是一种商业RTOS，需要购买许可证才能使用。

架构和内核：FreeRTOS采用基于优先级的抢占式内核架构，支持多任务处理、时间片轮转调度和中断服务机制。它提供了一套轻量级的内核函数和任务管理机制。μC/OS也是基于优先级的抢占式内核，但它提供了更多的功能，如事件标志、信号量、消息邮箱等，以满足更复杂的应用需求。

资源占用：FreeRTOS的内核非常小巧，具有低的存储器占用和快速的上下文切换速度，适用于资源有限的嵌入式系统。μC/OS相对而言具有更大的内核代码大小和更高的存储器占用，但它提供了更丰富的功能和可选组件。

硬件平台支持：FreeRTOS在多种处理器架构上都有支持，包括ARM、MIPS、x86等，因此它适用于广泛的硬件平台。μC/OS也支持多种处理器架构，但支持的硬件平台较少，且主要集中在微控制器和嵌入式系统上。

社区支持和生态系统：由于FreeRTOS的开源性质，它具有庞大的用户社区和广泛的生态系统，提供了丰富的示例代码、开发工具和支持资源。μC/OS作为商业RTOS，其用户社区和生态系统相对较小，但有专门的技术支持和服务。

## [在RTOS中，二值信号量和互斥量的区别？](#context.8)<a name="section.8"> </a>

二值信号量是一种计数器，只有两种状态：0和1。当一个任务试图获取一个已经被获取的二值信号量时，该任务会被挂起，直到该信号量被释放为止。二值信号量通常用于同步任务的开始或者结束，或者是保护共享资源的读写等。由于二值信号量不具有优先级继承功能，当高优先级任务等待低优先级任务释放二值信号量时，低优先级任务可能会优先执行，导致任务调度出现问题。

互斥量也是一种计数器，但它具有更多的状态。当一个任务获取一个已经被获取的互斥量时，该任务会被挂起，并且该互斥量的计数器会减一。只有当计数器归零时，该互斥量才会被释放。互斥量通常用于保护共享资源的读写等，它具有优先级继承功能，可以避免高优先级任务因为等待低优先级任务释放互斥量而被阻塞的问题。

## [在RTOS中，任务通知的运行机制是怎么样的？](#context.9)<a name="section.9"> </a>

1. 发送任务向接收任务发送通知，通知包括通知值和接收任务的句柄。
2. 接收任务准备好接收通知，并在等待通知列表中等待通知的到来。
3. 发送任务调用发送通知的API函数，RTOS将通知保存到接收任务的等待通知列表中。
4. 如果接收任务已经准备好接收通知，那么RTOS会将该任务从等待通知列表中移除，并唤醒该任务继续执行。
5. 如果接收任务没有准备好接收通知，那么该任务会继续等待，直到接收任务准备好接收通知。

## [UCOS任务调度](#context.10)<a name="section.10"> </a>

一个任务，也称作一个线程。

UCOS有一个任务调度机制，根据任务的优先级进行调度。

一个是硬件中断， 那么系统会将当前任务有关变量入栈，然后执行中断服务程序，执行完成后出栈返回.

另一个是任务之间的切换，使用的方法就是任务调度，每一个任务有自己的栈，顺度也是一样的入栈，然后执行另一个程序，然后出线返回。

 

并非是每一任务按优先级顺序轮流执行的，而是高优先级的任务独占运行，除非其主动放弃执行，否则低优先级任务不能抢占，同时高优先级可以把放出去给低优先级任务使用的CPU占用权抢回来。所以UCOS的任务间要注意插入等待延时，以便UCOS切出去让低优先级任务执行。

## [UCOS中任务间的通信](#context.11)<a name="section.11"> </a>

在UCOS中，是使用信号量、邮箱（消息邮箱）和消息队列这些被称作事件的中间环节来实现任务间的通信的，还有全局变量。

信号量用于：

1.控制共享资源的使用权（满足互斥条件）

2.标志某时间的发生

3.使2个任务的行为同步

消息队列：

概念：

（1）消息队列实际上就是邮箱阵列。

（2）任务和中断都可以将一则消息放入队列中，任务可以从消息队列中获取消息。

（3）先进入队列的消息先传给任务(FIFO)。

（4）每个消息队列有一张等待消息任务的等待列表，如果消息列中没有消息，则等待消息的任务就被挂起，直到消息到来。

## [STM32 中断是怎么进入到中断服务程序的](#context.12)<a name="section.12"> </a>

在STM32中，中断服务程序是通过中断向量表来实现的。中断向量表是一个包含中断处理程序入口地址的表格，每个中断都有一个对应的中断向量，当该中断发生时，CPU会根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断处理程序。

中断向量表的起始地址位于STM32的Flash或者SRAM中，中断向量表的长度是固定的，每个中断向量都包含了该中断的中断处理程序入口地址。

当中断发生时，STM32的CPU会保存当前执行的上下文，包括程序计数器（PC）和其他寄存器等，然后根据中断向量表找到该中断对应的中断处理程序入口地址，并跳转到该地址执行中断服务程序。中断服务程序执行完成后，CPU会根据保存的上下文恢复现场，并返回到中断发生前的执行位置继续执行。

## [UCOS中断处理过程](#context.13)<a name="section.13"> </a>

中断是一个硬件机制，主要用来向CPU通知一个异步事件发生了，这时CPU就会将当前CPU寄存器值入栈，然后转而执行中断服务程序，在CPU执行中断服务程序的时候可能有更高优先级的任务就绪，那么当退出中断服务程序的时候，CPU就会直接执行这个高优先级的任务。

UCOS是支持中断嵌套的，既高优先级的中断可以打断低优先级的中断，使用OSIntNestingCtr来记录中断嵌套次数，最大支持250级的中断嵌套。进去+1，退出-1。

在OSIntEnter()和OSIntExit()记录

## [DMA有什么用](#context.14)<a name="section.14"> </a>

DMA（Direct Memory Access，直接内存访问）是一种数据传输技术，它允许某些硬件子系统（例如外设控制器、IO设备等）直接在内存和外设之间传输数据，而无需CPU的干预。这样可以减轻CPU的负担，提高系统性能。

DMA的主要用途如下：

1. 减轻CPU负担：通过直接在内存和外设之间传输数据，DMA可以减少CPU的工作量，让CPU专注于其他任务或进入低功耗状态。
2. 提高数据传输速率：DMA通常能实现较高的数据传输速率，因为它绕过了CPU并直接访问内存，从而减少了延迟和额外的开销。
3. 实现实时数据传输：DMA可以实现更高的实时性，因为它可以在规定的时间内完成数据传输，而不会受到CPU其他任务的影响。
4. 节省功耗：通过减少CPU参与数据传输的次数，DMA可以降低系统功耗，特别是在低功耗设备或电池供电设备中。

DMA常用于以下场景：

1. 高速数据传输：例如，硬盘控制器、网络接口卡、音频设备等需要高速数据传输的应用。
2. 数据采集：例如，模数转换器（ADC）、数模转换器（DAC）等需要实时采集或输出数据的设备。
3. 图形处理：例如，图形处理器（GPU）在处理大量图像数据时，可以使用DMA加速数据传输。
4. 嵌入式系统：在嵌入式系统中，DMA可以用于减轻CPU负担，提高系统响应速度和性能。

## [处理器与外部设备通信的两种方式](#context.15)<a name="section.15"> </a>

1） 并行通信：数据各个位同时传输、速度较快、占用引脚资源多

2） 串行通信：数据按位顺序传输、速度较慢、占用引脚资源少

## [串行通信的通信方式](#context.16)<a name="section.16"> </a>

1） 同步通信：带时钟同步信号传输，SPI（全双工）、I2C（半双工）

2） 异步通信：不带时钟同步信号，UART（全双工）、单总线（半双工）

## [串行通信分为](#context.17)<a name="section.17"> </a>

1） 单工：数据传输只支持数据在一个方向上传输

2） 半双工：允许数据在两个方向上传输，但在某一时刻只允许数据在一个方向上传输

3） 全双工：允许数据同时在两个方向上传输，要求收发设备都有独立的接收、发送能力

## [Modbus通讯协议](#context.18)<a name="section.18"> </a>

Modbus协议使用的是主从通讯技术，即由主设备主动查询和操作从站设备。

其通信遵循以下的过程：

- 主设备向从设备发送请求
- 从设备分析并处理主设备的请求，然后向主设备发送结果
- 如果出现任何差错，从设备将返回一个异常功能码 

Modbus协议的报文（或帧）的基本格式是：

功能码和数据区在不同类型的网络都是固定不变的，表头和校验码则因网络底层的实现方式不同而有所区别。表头包含了从站的地址，功能码告诉从站要执行何种功能，数据区是具体的信息。

Modbus有下列三种通信方式：

（1）以太网：对应的通信模式是

（2）异步串行传输（各种介质如有线RS-232-/422/485/；光纤、无线等）：对应的通信模式是Modbus RTU 或 Modbus ASCII

（3）高速令牌传递网络：对应的通信模式是Modbus PLUS

## [485通讯的原理](#context.19)<a name="section.19"> </a>

1. 物理层：485通讯使用两根信号线，分别为A线和B线，以及一个共享的地线（GND）。A线和B线分别用于发送和接收数据，可以进行全双工通信。在通讯过程中，A线和B线的电平可以相互翻转，用来表示不同的逻辑状态，如高电平表示逻辑"1"，低电平表示逻辑"0"。
2. 差分信号：485通讯采用差分信号传输，即在A线和B线之间的电压差（差分电平）来表示数据。发送端根据要发送的数据，将A线和B线上的电平进行翻转，形成一个差分信号，接收端根据电压差的大小来判断接收到的数据是逻辑"1"还是逻辑"0"。
3. 驱动能力：485通讯使用驱动能力较强的驱动器芯片，能够提供足够的电流来驱动长距离的传输线路。这使得485通讯可以在远距离的环境中进行数据传输，通常可以覆盖数千米的传输距离。
4. 数据帧格式：485通讯中的数据通常以数据帧的形式进行传输。一般包括起始位（Start Bit）、数据位（Data Bits）、校验位（Parity Bit）和停止位（Stop Bit）。起始位和停止位用于标识数据帧的开始和结束，数据位用于携带实际的数据，校验位用于检测数据传输的错误。
5. 通讯模式：485通讯可以进行点对点通讯或多点通讯。在点对点通讯中，一个发送器和一个接收器直接进行通讯。在多点通讯中，多个设备可以通过一个共享的总线进行通讯，通过给每个设备分配不同的地址来实现数据的选择性接收。

## [RS485和RS232的区别](#context.20)<a name="section.20"> </a>

1. 通信方式：RS232：RS232是一种点对点通信方式，即一对发送器和接收器之间进行直接通信。只有一个发送器和一个接收器参与通信。RS485：RS485是一种多点通信方式，可以在一个总线上连接多个发送器和接收器，实现多个设备之间的通信。
2. 信号电平：RS232：RS232使用负逻辑电平表示逻辑“1”（-3V至-15V）和正逻辑电平表示逻辑“0”（+3V至+15V）。RS485：RS485使用差分信号传输，即A线和B线之间的电压差表示数据。电平差分范围可以根据需要调整，一般为-7V至-12V表示逻辑“1”和+7V至+12V表示逻辑“0”。
3. 传输距离：RS232：RS232通常适用于短距离通信，最常见的距离为15米左右。RS485：RS485具有较强的驱动能力，能够支持长距离通信，一般可达数千米，这使得它适用于工业环境中的长距离通信需求。
4. 多点通信：RS232：由于是点对点通信，RS232通常无法实现多个设备之间的直接通信。如果需要多点通信，需要采用额外的协议或设备。RS485：RS485支持多点通信，可以在同一总线上连接多个设备，通过为每个设备分配不同的地址来实现数据的选择性接收。

## [串口通信协议UART](#context.21)<a name="section.21"> </a>

UART（通用异步收/发器）是我们单片机的串口通信接口，为全双工串行异步，UART通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。

![img](https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943445277/D2B5CA33BD970F64A6301FA75AE2EB22)

在串口通讯的协议层中，规定了数据包的内容，它由起始位，主体数据，校验位以及停止位组成，通讯双方的数据包格式以及波特率要约定一致才能正常收发数据。

串口设置的一般步骤可以总结为如下几个步骤：

\1) 串口时钟使能，GPIO 时钟使能。

\2) 设置引脚复用器映射：调用 GPIO_PinAFConfig 函数。

\3) GPIO 初始化设置：要设置模式为复用功能。

\4) 串口参数初始化：设置波特率，字长，奇偶校验等参数。

\5) 开启中断并且初始化 NVIC，使能中断（如果需要开启中断才需要这个步骤）。

\6) 使能串口。

\7) 编写中断处理函数：函数名格式为 USARTxIRQHandler(x 对应串口号)。

## [串口异步通信](#context.22)<a name="section.22"> </a>

起始位、数据位、奇偶校验位、停止位、波特率设置

![img](https://uploadfiles.nowcoder.com/images/20230628/993465112_1687943493927/D2B5CA33BD970F64A6301FA75AE2EB22)

## [SPI（串行外围设备接口）](#context.23)<a name="section.23"> </a>

SPI（全双工同步通信）

以主从方式工作，这种模式通常有一个主设备和一个或多 个从设备，需要至少4根线，它们是SDI (数据输入)、SDO (数据输出)、SCLK (时钟)、CS (片选)。

\1. SDO/MOSI – 主设备数据输出，从设备数据输入;

\2. SDI/MISO – 主设备数据输入，从设备数据输出;

\3. SCLK – 时钟信号，由主设备产生;

4.CS/SS – 从设备使能信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时需要将从设备对应的片选引脚电平拉低或者是拉高。

CS片选信号，由主设备控制。当有多个从设备的时候，因为每个从设备上都有一个片选引脚接入到主设备机中，当我们的主设备和某个从设备通信时将需要将从设备对应的片选引脚电平拉低或者是拉高（本设计是拉低则为选中）

多从机模式：

第一种多CS，每个从机都需要一条单独的SS线；第二种菊花链，在设备信号（总线信号或中断信号）以串行的方式从一个设备依次传到下一个设备，不断循环直到数据到达目标设备。

SPI通讯的优势：

- 全双工串行通信；
- 高速数据传输速率。
- 简单的软件配置；
- 极其灵活的数据传输，不限于8位，它可以是任意大小的字；
- 非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器/晶振（与UART不同）。不需要收发器（与CAN不同）。

SPI的缺点：

- 没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；
- 通常仅支持一个主设备；
- 需要更多的引脚（与I2C不同）；
- 没有定义硬件级别的错误检查协议；
- 与RS-232和CAN总线相比，只能支持非常短的距离；

## [SPI是什么？有几条线？几种模式？](#context.24)<a name="section.24"> </a>

SPI，全称为Serial Peripheral Interface，是一种串行的通信协议，用于在单片机和外设之间进行通信。SPI协议通常用于连接低速的外设，例如存储器、传感器、显示器、通信芯片等。

SPI通信需要至少四条线，包括：

1. MOSI（Master Output, Slave Input）：主设备输出，从设备输入。
2. MISO（Master Input, Slave Output）：主设备输入，从设备输出。
3. SCLK（Serial Clock）：时钟线，由主设备控制。
4. SS（Slave Select）：从设备选择线，由主设备控制，可以用来选择不同的从设备进行通信。

SPI协议有四种模式，每种模式具有不同的时序和时钟极性，包括：

1. 模式0：时钟极性为0，时钟相位为0，数据在时钟的下降沿被采样。
2. 模式1：时钟极性为0，时钟相位为1，数据在时钟的上升沿被采样。
3. 模式2：时钟极性为1，时钟相位为0，数据在时钟的上升沿被采样。
4. 模式3：时钟极性为1，时钟相位为1，数据在时钟的下降沿被采样。

不同的模式适用于不同的硬件设备和通信要求，需要根据具体的需求进行选择和配置。

## [IIC](#context.25)<a name="section.25"> </a>

1.它是总线，即它可以接入多个从设备

2.它只有两根线，即时钟线（SCL）,数据线（SDA）,但是它同一时间只有做发送或者接收线

3.每个连接到总线的设备，都要支持IIC，即有自己的设备地址，主机就是靠这个来区别不同的设备的

4.总线通过上拉电阻接到电源，即当空闲时，是高电平

5.多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。

6.具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式

空闲状态：I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。

开始信号：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。

结束信号：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。

应答信号：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的低电平脉冲， 表示已收到数据。(主设备在SCL线上产生每个时钟脉冲，将在SDA线上传输一个数据位，当一个字节按数据位从高位到低位的顺序传输完后，紧接着从设备将拉低SDA线，回传给主设备一个应答位（ACK），此时才认为一个字节真正的被传输完成。)

CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接 收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为 受控单元出现故障。

## [CAN通信介绍](#context.26)<a name="section.26"> </a>

CAN（Controller Area Network）通信是一种串行通信协议，其主要原理如下：

1. 差分传输：CAN通信采用差分传输方式，即将数据信号和参考信号相减得到差分信号进行传输，可以有效地抵消噪声干扰，提高传输质量和可靠性。
2. 帧格式：CAN通信采用基于帧的数据传输方式，每个数据帧包括了ID、数据和控制信息等多个部分。其中，ID用于区分不同的设备和数据类型，数据用于存储实际的数据信息，控制信息用于控制数据的发送和接收等操作。
3. 网络拓扑：CAN通信的网络拓扑结构可以是总线型、星型或混合型，其中最常见的是总线型拓扑结构。在总线型拓扑结构中，所有的设备都连接到同一根总线上，通过差分传输的方式进行数据交换。
4. 硬件控制：CAN通信的硬件控制主要包括时钟同步、数据帧的发送和接收、差分信号的转换和电平调整等。其中，时钟同步是保证通信数据同步的关键因素，CAN总线会在通信开始前进行同步校验以确保数据的正确性。
5. 协议控制：CAN通信的协议控制包括数据的编码和解码、数据的传输确认和错误检测等。其中，数据的编码和解码是保证数据正确传输的关键因素，通过差分传输方式进行数据传输，CAN控制器会对数据进行检验和校验等操作以确保数据的正确性。

## [传输速度](#context.27)<a name="section.27"> </a>

比特率（Bit/s）和波特率，比特率是从单位看就可以知道是指每秒传输二进制的位数，而波特率是指每秒传输的码元；这里的码元我们给具体化，大家都知道串口，他的数据以帧格式传输的，即一个起始位+8位数据位+1位奇偶位+1位结束位，那么这里时候，这11位加在一起就是一个码元。

# cache的作用

缓存（Cache）是计算机系统中一种用于存储临时数据的高速存储器。它位于CPU和主存储器（如RAM）之间，用于加速对经常访问数据的读取和写入操作。缓存的主要作用是减少CPU与慢速存储器（如RAM）之间的速度差异，从而提高系统性能。

# 有cache的CPU上使用DMA如何保证数据的一致性

缓存一致性是指确保CPU通过缓存访问的数据与内存中的实际数据保持一致。如果缓存中的数据与内存中的数据不一致，可能会导致错误的计算结果或系统行为。

在使用DMA时，可能会发生以下情况：

1. DMA将数据写入内存，但CPU缓存中仍然保存有旧数据。
2. CPU将数据写入缓存，但DMA从内存中读取的是旧数据。

为了确保数据一致性，可以采取以下策略：

1. 缓存刷新（Cache Flushing）：在DMA传输之前或之后，可以刷新缓存，以确保内存中的数据与缓存中的数据一致。例如，在DMA写操作之后，可以将缓存中受影响的数据行（Cache Line）标记为无效，从而在下次访问时强制从内存重新加载数据；在DMA读操作之前，可以将修改过的缓存数据写回内存，以确保DMA读取到的是最新数据。
2. 缓存一致性协议（Cache Coherency Protocol）：某些处理器支持硬件缓存一致性协议，如MESI协议（Modified, Exclusive, Shared, and Invalid），用于自动维护多个缓存之间的数据一致性。这种协议可以在多核处理器或多处理器系统中使用，以便在DMA传输时自动更新相关缓存数据。
3. 无缓存访问（Uncached Access）：在某些情况下，可以将DMA操作的内存区域配置为无缓存访问，即CPU直接访问内存，而不经过缓存。这样可以避免缓存一致性问题，但可能会降低数据访问性能。
4. 使用缓冲区同步技术：某些操作系统或驱动程序可以提供缓冲区同步技术，如Linux内核中的函数，用于确保DMA操作和CPU访问之间的缓存一致性。